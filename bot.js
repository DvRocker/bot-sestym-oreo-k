const Discord = require('discord.js');
const client = new Discord.Client();
var prefix = "!"




client.on("guildMemberAdd", member => {
  let guild = member.guild;
  guild.defaultChannel.sendMessage("", {embed: {
  color: 808080,
  author: {
    name: member.user.username,
    icon_url: member.user.avatarURL
  },
  title: guild.name,
  description: ' *** Go to : #update [ ${member}  ] *** !',
}}).catch(console.error);
  }
);




client.on('message', message => {
         if(message.content === prefix + "closeroom") {
                             if(!message.channel.guild) return message.reply('** This command only for servers**');
  
     if(!message.member.hasPermission('MANAGE_MESSAGES')) return message.reply(' **__Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ§Øª__**');
                message.channel.overwritePermissions(message.guild.id, {
              SEND_MESSAGES: false
  
                }).then(() => {
                    message.reply("**__ØªÙ… ØªÙ‚ÙÙŠÙ„ Ø§Ù„Ø´Ø§Øª__ âœ… **")
                });
                  }
      if(message.content === prefix + "openroom") {
                          if(!message.channel.guild) return message.reply('** This command only for servers**');
  
     if(!message.member.hasPermission('MANAGE_MESSAGES')) return message.reply('**__Ù„ÙŠØ³ Ù„Ø¯ÙŠÙƒ ØµÙ„Ø§Ø­ÙŠØ§Øª__**');
                message.channel.overwritePermissions(message.guild.id, {
              SEND_MESSAGES: true
  
                }).then(() => {
                    message.reply("**__ØªÙ… ÙØªØ­ Ø§Ù„Ø´Ø§Øª__âœ…**")
                });
      }
         
});



client.on('message',async message => {
  if(message.author.bot) return;
if(message.content.indexOf(prefix) !== 0) return;
const args = message.content.slice(prefix.length).trim().split(/ +/g);
const command = args.shift().toLowerCase();
if(command === "start") {
var title = args[0].split('-').join(" ");
if(args[2]) {
  message.channel.send(` \`\`\`MD
  # Title format <word>-<word>-<word> 
  < do not use spaces use - insted
   \`\`\``);
}
var time = args[1].split(":");
var sec = time[3];
var min = time[2];
var hou = time[1];
var day = time[0];

if((hou * 1) > 24) {
  message.channel.send(` \`\`\`MD
  # time format <days> : <hours> : <minutes> : <secondes>
  < hours must be 24 or less
   \`\`\``);
}
else if((sec * 1) > 60) {
  message.channel.send(` \`\`\`MD
  # time format <days> : <hours> : <minutes> : <secondes>
  < minutes must be 60 or less 
  \`\`\``);
}
else if((min * 1) > 60) {
  message.channel.send(` \`\`\`MD
  # time format <days> : <hours> : <minutes> : <secondes>
  < seconds must be 60 or less
  \`\`\``);
} 
else  {

var upgradeTime = sec;
upgradeTime = upgradeTime * 2 / 2 + (min * 60);
upgradeTime = upgradeTime * 2 / 2 + (hou * 60 * 60);
upgradeTime = upgradeTime * 2 / 2 + (day * 24 * 60 * 60);
var seconds = upgradeTime;
var duration = (upgradeTime * 1000)
  if(!message.guild.member(message.author).hasPermission('MANAGE_GUILD')) return message.channel.send(':heavy_multiplication_x:| **s You Dont Have Premission**');
  if(!args) return message.channel.send(`**Use : #start  <Presentse> <Time>**`);
  if(!title) return message.channel.send(`**Use : **\`#start ${args[0]} Minutes\`** <Presentse>**`);
  if(!isNaN(args[1])) return message.channel.send(':heavy_multiplication_x:| **The Time Be Nambers `` Do the Commend Agin``**');
        let giveEmbed = new Discord.RichEmbed()
      .setAuthor(message.guild.name, message.guild.iconURL)
      .setDescription(`**${title}** \nReact Whit ğŸ To Enter! \n**Ends  after   ${day} day  ${hou} hour  ${min} minute ${sec} second**`)
      .setFooter(message.author.username, message.author.avatarURL);
      message.channel.send(' :heavy_check_mark: **Giveaway Created** :heavy_check_mark:' , {embed: giveEmbed}).then(m => {
          message.delete();
          m.react('ğŸ');
              var giveAwayCut = setInterval(function() {
                  var days        = Math.floor(seconds/24/60/60);
                  var hoursLeft   = Math.floor((seconds) - (days*86400));
                  var hours       = Math.floor(hoursLeft/3600);
                  var minutesLeft = Math.floor((hoursLeft) - (hours*3600));
                  var minutes     = Math.floor(minutesLeft/60);
                  var remainingSeconds = seconds % 60;
                  if (seconds != 0) {
                    seconds--;
                  }
              let updateGiveEmbed = new Discord.RichEmbed()
              .setAuthor(message.guild.name, message.guild.iconURL)
              .setDescription(`**${title}** \nReact With ğŸ To Enter! \n**Ends  after   ${days} day  ${hours} hour  ${minutes} minute ${remainingSeconds} second**`)
              .setFooter(message.author.username, message.author.avatarURL);
              m.edit(updateGiveEmbed)
            }, 1000);
         setTimeout(() => {
          clearInterval(giveAwayCut)
           let users = m.reactions.get("ğŸ").users;
           let list = users.array().filter(u => u.id !== client.user.id);
           let gFilter = list[Math.floor(Math.random() * list.length) + 0]
           let endEmbed = new Discord.RichEmbed()
           endEmbed.setAuthor(message.author.username, message.author.avatarURL)
           endEmbed.setTitle(title)
           endEmbed.addField('Giveaway End !ğŸ',`Winners : ${gFilter}`)
         m.edit('** ğŸ GIVEAWAY ENDED ğŸ**' , {embed: endEmbed});
         },duration);
       });
  }
}
});
 
 


client.on('message', message => {
   if (message.content === "!id") {
   let embed = new Discord.RichEmbed()
  .setColor("RANDOM")
  .setThumbnail(message.author.avatarURL)
  .addField("Name:",`${message.author.username}`, true)
  .addField('Discrim:',"#" + `${message.author.discriminator}`, true)
  .addField("ID:", `${message.author.id}`, true)
  .addField("Create At:", `${message.author.createdAt}`, true)
  message.channel.sendEmbed(embed);
    }
});

clinet.on ("guildMemberAdd", member => {
  
   var role = member.guild.roles.find ("name", "Ã’reo");
   member.addRole (role);
  
})

clinet.on ("guildMemberRemove", member => {
   
})



client.on('message', (message) => {
    if (message.content.startsWith('!kick')) {
        var member= message.mentions.members.first();
        member.kick().then((member) => {
            message.channel.send(member.displayName + ' ØªÙ… Ø·Ø±Ø¯ Ù‡Ø°Ø§ Ø§Ù„Ø´Ø®Øµ Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±');
        }).catch(() => {
            message.channel.send(":x:");
        });
    }
});
 
 
client.on('message', (message) => {
    if (message.content.startsWith('!ban ')) {
      if(!message.member.hasPermission('BAN_MEMBERS')) return message.reply('Ù‡Ø°Ø§ Ø§Ù„Ø®Ø§ØµÙŠØ© Ù„Ù„Ø¯Ø§Ø±Ø© ÙÙ‚Ø·');
        var member= message.mentions.members.first();
        member.ban().then((member) => {
         message.channel.send(member.displayName + 'ØªÙ… Ø·Ø±Ø¯ Ù‡Ø°Ø§ Ø§Ù„Ø´Ø®Øµ Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±');
        }).catch(() => {
            message.channel.send('Error :_:');
        });
    }
});


client.on('message', message => {
    if (message.content.startsWith("!avatar")) {
        var mentionned = message.mentions.users.first();
    var x5bzm;
      if(mentionned){
          var x5bzm = mentionned;
      } else {
          var x5bzm = message.author;
          
      }
        const embed = new Discord.RichEmbed()
        .setColor("RANDOM")
        .setImage(`${x5bzm.avatarURL}`)
      message.channel.sendEmbed(embed);
    }
});


client.on("message", message => {
    var prefix = "!";
            var args = message.content.substring(prefix.length).split(" ");
            if (message.content.startsWith(prefix + "clear")) {
 if (!args[1]) {
                                let x5bz1 = new Discord.RichEmbed()
                                .setDescription("!clear <number>")
                                .setColor("#0000FF")
                                message.channel.sendEmbed(x5bz1);
                            } else {
                            let messagecount = parseInt(args[1]);
                            message.channel.fetchMessages({limit: messagecount}).then(messages => message.channel.bulkDelete(messages));
                                                          message.channel.fetchMessages({limit: messagecount}).then(messages => message.channel.bulkDelete(messages));
                            message.channel.fetchMessages({limit: messagecount}).then(messages => message.channel.bulkDelete(messages));
                            let x5bz2 = new Discord.RichEmbed()
                                                            .setColor("#008000")
                                .setDescription(":white_check_mark: | Delete " + args[1] + " Message!")
                                                                                        message.delete("..");
                                message.channel.sendEmbed(x5bz2);
                            }
                          }
});

lient.on('message', message => {
    if(message.content == prefix + 'server') {
        var servername = message.guild.name
        var Ø§ÙˆÙ†Ø± = message.guild.owner
        var Ø§Ø¹Ø¶Ø§Ø¡ = message.guild.memberCount
        var Ø§ÙŠØ¯ÙŠ = message.guild.id
        var Ø¨Ù„Ø¯Ø§Ù„Ø³ÙŠØ±ÙØ± = message.guild.region
        var Ø§Ù„Ø±ÙˆÙ…Ø§Øª = message.guild.channels.size
        var Ø§Ù„Ø±ØªØ¨ = message.guild.roles
        var Ø¹Ù…Ù„ = message.guild.createdAt
        var Ø§Ù„Ø±ÙˆÙ… = message.guild.defaultChannel
        var server = new Discord.RichEmbed()
        .setThumbnail(message.guild.iconURL)
        .addField('Ø§Ø³Ù… Ø§Ù„Ø³ÙŠØ±ÙØ±', servername)
        .addField('Ø§ÙŠ Ø¯ÙŠ Ø§Ù„Ø³ÙŠØ±ÙØ± ' , [Ø§ÙŠØ¯ÙŠ])
        .addField('Ø£Ø¹Ø¶Ø§Ø¡ Ø§Ù„Ø³ÙŠØ±ÙØ±', Ø§Ø¹Ø¶Ø§Ø¡)
        .addField('Ø±ÙˆÙ…Ø§Øª Ø§Ù„Ø³ÙŠØ±ÙØ±', Ø§Ù„Ø±ÙˆÙ…Ø§Øª)
        .addField('Ø±ÙˆÙ… Ø§Ù„Ø´Ø§Øª Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ', Ø§Ù„Ø±ÙˆÙ…)
        .addField('ØµØ§Ø­Ø¨ Ø§Ù„Ø³ÙŠØ±ÙØ±', Ø§ÙˆÙ†Ø±)
        .addField('Ø¨Ù„Ø¯ Ø§Ù„Ø³ÙŠØ±ÙØ±', Ø¨Ù„Ø¯Ø§Ù„Ø³ÙŠØ±ÙØ±)
        .addField('ØªØ§Ø±ÙŠØ® Ø§ÙØªØªØ§Ø­ Ø§Ù„Ø³ÙŠØ±ÙØ±', Ø¹Ù…Ù„)
        .setColor('RANDOM')

        message.channel.sendEmbed(server)
    }
});


client.login(process.env.BOT_TOKEN);


